{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _declaration = _interopRequireDefault(require(\"./declaration\"));\nvar _tokenize = _interopRequireDefault(require(\"./tokenize\"));\nvar _comment = _interopRequireDefault(require(\"./comment\"));\nvar _atRule = _interopRequireDefault(require(\"./at-rule\"));\nvar _root = _interopRequireDefault(require(\"./root\"));\nvar _rule = _interopRequireDefault(require(\"./rule\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(input) {\n    this.input = input;\n    this.root = new _root.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n  var _proto = Parser.prototype;\n  _proto.createTokenizer = function createTokenizer() {\n    this.tokenizer = (0, _tokenize.default)(this.input);\n  };\n  _proto.parse = function parse() {\n    var token;\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n        case ';':\n          this.freeSemicolon(token);\n          break;\n        case '}':\n          this.end(token);\n          break;\n        case 'comment':\n          this.comment(token);\n          break;\n        case 'at-word':\n          this.atrule(token);\n          break;\n        case '{':\n          this.emptyRule(token);\n          break;\n        default:\n          this.other(token);\n          break;\n      }\n    }\n    this.endFile();\n  };\n  _proto.comment = function comment(token) {\n    var node = new _comment.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n  _proto.emptyRule = function emptyRule(token) {\n    var node = new _rule.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n  _proto.other = function other(start) {\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var tokens = [];\n    var token = start;\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n      token = this.tokenizer.nextToken();\n    }\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n      this.decl(tokens);\n    } else {\n      this.unknownWord(tokens);\n    }\n  };\n  _proto.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n  _proto.decl = function decl(tokens) {\n    var node = new _declaration.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n    while (tokens.length) {\n      var type = tokens[0][0];\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n      node.prop += tokens.shift()[1];\n    }\n    node.raws.between = '';\n    var token;\n    while (tokens.length) {\n      token = tokens.shift();\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n        node.raws.between += token[1];\n      }\n    }\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n          str = cache.pop()[1] + str;\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n  _proto.atrule = function atrule(token) {\n    var node = new _atRule.default();\n    node.name = token[1].slice(1);\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n    this.init(node, token[2], token[3]);\n    var prev;\n    var shift;\n    var last = false;\n    var open = false;\n    var params = [];\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1;\n          prev = params[shift];\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift];\n          }\n          if (prev) {\n            node.source.end = {\n              line: prev[4],\n              column: prev[5]\n            };\n          }\n        }\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n  _proto.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n  _proto.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n  _proto.freeSemicolon = function freeSemicolon(token) {\n    this.spaces += token[1];\n    if (this.current.nodes) {\n      var prev = this.current.nodes[this.current.nodes.length - 1];\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  } // Helpers\n  ;\n\n  _proto.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n  _proto.raw = function raw(node, prop, tokens) {\n    var token, type;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    var next, prev;\n    var pattern = /^([.|#])?([\\w])+/i;\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n        continue;\n      }\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n    node[prop] = value;\n  };\n  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  };\n  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next;\n    var spaces = '';\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n    return spaces;\n  };\n  _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  };\n  _proto.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n  _proto.colon = function colon(tokens) {\n    var brackets = 0;\n    var token, type, prev;\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n      if (type === '(') {\n        brackets += 1;\n      }\n      if (type === ')') {\n        brackets -= 1;\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n      prev = token;\n    }\n    return false;\n  } // Errors\n  ;\n\n  _proto.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n  _proto.unknownWord = function unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n  };\n  _proto.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n  _proto.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n  _proto.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n  _proto.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n  _proto.precheckMissedSemicolon = function precheckMissedSemicolon() /* tokens */\n  {// Hook for Safe Parser\n  };\n  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token;\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n  return Parser;\n}();\nexports.default = Parser;\nmodule.exports = exports.default;","map":{"version":3,"names":["_declaration","_interopRequireDefault","require","_tokenize","_comment","_atRule","_root","_rule","Parser","input","root","default","current","spaces","semicolon","createTokenizer","source","start","line","column","tokenizer","parse","token","endOfFile","nextToken","freeSemicolon","end","comment","atrule","emptyRule","other","endFile","node","init","text","slice","test","raws","left","right","match","selector","between","type","colon","bracket","brackets","tokens","push","length","decl","rule","back","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","last","before","shift","prop","spacesAndCommentsFromStart","precheckMissedSemicolon","i","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","j","_type","trim","indexOf","value","checkMissedSemicolon","name","unnamedAtrule","prev","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","ownSemicolon","clean","next","pattern","reduce","all","lastTokenType","from","result","splice","doubleColon","error","pos","founded"],"sources":["C:\\Users\\dyd97\\OneDrive\\바탕 화면\\test-main\\node_modules\\postcss\\lib\\parser.es6"],"sourcesContent":["import Declaration from './declaration'\nimport tokenizer from './tokenize'\nimport Comment from './comment'\nimport AtRule from './at-rule'\nimport Root from './root'\nimport Rule from './rule'\n\nexport default class Parser {\n  constructor (input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { line: 1, column: 1 } }\n  }\n\n  createTokenizer () {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse () {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment (token) {\n    let node = new Comment()\n    this.init(node, token[2], token[3])\n    node.source.end = { line: token[4], column: token[5] }\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule (token) {\n    let node = new Rule()\n    this.init(node, token[2], token[3])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other (start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0]\n        if (token !== 'space' && token !== 'comment') break\n        this.tokenizer.back(tokens.pop())\n      }\n      this.decl(tokens)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule (tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2], tokens[0][3])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl (tokens) {\n    let node = new Declaration()\n    this.init(node)\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n    if (last[4]) {\n      node.source.end = { line: last[4], column: last[5] }\n    } else {\n      node.source.end = { line: last[2], column: last[3] }\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = { line: tokens[0][2], column: tokens[0][3] }\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n    node.raws.between += this.spacesAndCommentsFromStart(tokens)\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    this.raw(node, 'value', tokens)\n\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens)\n  }\n\n  atrule (token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2], token[3])\n\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      if (token[0] === ';') {\n        node.source.end = { line: token[2], column: token[3] }\n        this.semicolon = true\n        break\n      } else if (token[0] === '{') {\n        open = true\n        break\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1\n          prev = params[shift]\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift]\n          }\n          if (prev) {\n            node.source.end = { line: prev[4], column: prev[5] }\n          }\n        }\n        this.end(token)\n        break\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = { line: token[4], column: token[5] }\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end (token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = { line: token[2], column: token[3] }\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile () {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon (token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  init (node, line, column) {\n    this.current.push(node)\n\n    node.source = { start: { line, column }, input: this.input }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw (node, prop, tokens) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n    let pattern = /^([.|#])?([\\w])+/i\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1]\n        next = tokens[i + 1]\n\n        if (\n          prev[0] !== 'space' &&\n          next[0] !== 'space' &&\n          pattern.test(prev[1]) &&\n          pattern.test(next[1])\n        ) {\n          value += token[1]\n        } else {\n          clean = false\n        }\n\n        continue\n      }\n\n      if (type === 'comment' || (type === 'space' && i === length - 1)) {\n        clean = false\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart (tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom (tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon (tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let i = 0; i < tokens.length; i++) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket (bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3])\n  }\n\n  unknownWord (tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3])\n  }\n\n  unexpectedClose (token) {\n    throw this.input.error('Unexpected }', token[2], token[3])\n  }\n\n  unclosedBlock () {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon (token) {\n    throw this.input.error('Double colon', token[2], token[3])\n  }\n\n  unnamedAtrule (node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3])\n  }\n\n  precheckMissedSemicolon (/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon (tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2], token[3])\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}