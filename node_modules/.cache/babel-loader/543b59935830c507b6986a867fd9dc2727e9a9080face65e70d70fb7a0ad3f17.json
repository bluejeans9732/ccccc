{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _picocolors = _interopRequireDefault(require(\"picocolors\"));\nvar _terminalHighlight = _interopRequireDefault(require(\"./terminal-highlight\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\n/**\n * The CSS parser throws this error for broken CSS.\n *\n * Custom parsers can throw this error for broken custom syntax using\n * the {@link Node#error} method.\n *\n * PostCSS will use the input source map to detect the original error location.\n * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n * PostCSS will show the original position in the Sass file.\n *\n * If you need the position in the PostCSS input\n * (e.g., to debug the previous compiler), use `error.input.file`.\n *\n * @example\n * // Catching and checking syntax error\n * try {\n *   postcss.parse('a{')\n * } catch (error) {\n *   if (error.name === 'CssSyntaxError') {\n *     error //=> CssSyntaxError\n *   }\n * }\n *\n * @example\n * // Raising error from plugin\n * throw node.error('Unknown variable', { plugin: 'postcss-vars' })\n */\nvar CssSyntaxError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(CssSyntaxError, _Error);\n\n  /**\n   * @param {string} message  Error message.\n   * @param {number} [line]   Source line of the error.\n   * @param {number} [column] Source column of the error.\n   * @param {string} [source] Source code of the broken file.\n   * @param {string} [file]   Absolute path to the broken file.\n   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.\n   */\n  function CssSyntaxError(message, line, column, source, file, plugin) {\n    var _this;\n    _this = _Error.call(this, message) || this;\n    /**\n     * Always equal to `'CssSyntaxError'`. You should always check error type\n     * by `error.name === 'CssSyntaxError'`\n     * instead of `error instanceof CssSyntaxError`,\n     * because npm could have several PostCSS versions.\n     *\n     * @type {string}\n     *\n     * @example\n     * if (error.name === 'CssSyntaxError') {\n     *   error //=> CssSyntaxError\n     * }\n     */\n\n    _this.name = 'CssSyntaxError';\n    /**\n     * Error message.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'Unclosed block'\n     */\n\n    _this.reason = message;\n    if (file) {\n      /**\n       * Absolute path to the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.file       //=> 'a.sass'\n       * error.input.file //=> 'a.css'\n       */\n      _this.file = file;\n    }\n    if (source) {\n      /**\n       * Source code of the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.source       //=> 'a { b {} }'\n       * error.input.column //=> 'a b { }'\n       */\n      _this.source = source;\n    }\n    if (plugin) {\n      /**\n       * Plugin name, if error came from plugin.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.plugin //=> 'postcss-vars'\n       */\n      _this.plugin = plugin;\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      /**\n       * Source line of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.line       //=> 2\n       * error.input.line //=> 4\n       */\n      _this.line = line;\n      /**\n       * Source column of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.column       //=> 1\n       * error.input.column //=> 4\n       */\n\n      _this.column = column;\n    }\n    _this.setMessage();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError);\n    }\n    return _this;\n  }\n  var _proto = CssSyntaxError.prototype;\n  _proto.setMessage = function setMessage() {\n    /**\n     * Full error text in the GNU error format\n     * with plugin, file, line and column.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'a.css:1:1: Unclosed block'\n     */\n    this.message = this.plugin ? this.plugin + ': ' : '';\n    this.message += this.file ? this.file : '<css input>';\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column;\n    }\n    this.message += ': ' + this.reason;\n  }\n  /**\n   * Returns a few lines of CSS source that caused the error.\n   *\n   * If the CSS has an input source map without `sourceContent`,\n   * this method will return an empty string.\n   *\n   * @param {boolean} [color] Whether arrow will be colored red by terminal\n   *                          color codes. By default, PostCSS will detect\n   *                          color support by `process.stdout.isTTY`\n   *                          and `process.env.NODE_DISABLE_COLORS`.\n   *\n   * @example\n   * error.showSourceCode() //=> \"  4 | }\n   *                        //      5 | a {\n   *                        //    > 6 |   bad\n   *                        //        |   ^\n   *                        //      7 | }\n   *                        //      8 | b {\"\n   *\n   * @return {string} Few lines of CSS source that caused the error.\n   */;\n\n  _proto.showSourceCode = function showSourceCode(color) {\n    var _this2 = this;\n    if (!this.source) return '';\n    var css = this.source;\n    if (_terminalHighlight.default) {\n      if (typeof color === 'undefined') color = _picocolors.default.isColorSupported;\n      if (color) css = (0, _terminalHighlight.default)(css);\n    }\n    var lines = css.split(/\\r?\\n/);\n    var start = Math.max(this.line - 3, 0);\n    var end = Math.min(this.line + 2, lines.length);\n    var maxWidth = String(end).length;\n    function mark(text) {\n      if (color && _picocolors.default.red) {\n        return _picocolors.default.red(_picocolors.default.bold(text));\n      }\n      return text;\n    }\n    function aside(text) {\n      if (color && _picocolors.default.gray) {\n        return _picocolors.default.gray(text);\n      }\n      return text;\n    }\n    return lines.slice(start, end).map(function (line, index) {\n      var number = start + 1 + index;\n      var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n      if (number === _this2.line) {\n        var spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, _this2.column - 1).replace(/[^\\t]/g, ' ');\n        return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^');\n      }\n      return ' ' + aside(gutter) + line;\n    }).join('\\n');\n  }\n  /**\n   * Returns error position, message and source code of the broken part.\n   *\n   * @example\n   * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n   *                  //    > 1 | a {\n   *                  //        | ^\"\n   *\n   * @return {string} Error position, message and source code.\n   */;\n\n  _proto.toString = function toString() {\n    var code = this.showSourceCode();\n    if (code) {\n      code = '\\n\\n' + code + '\\n';\n    }\n    return this.name + ': ' + this.message + code;\n  }\n  /**\n   * @memberof CssSyntaxError#\n   * @member {Input} input Input object with PostCSS internal information\n   *                       about input file. If input has source map\n   *                       from previous tool, PostCSS will use origin\n   *                       (for example, Sass) source. You can use this\n   *                       object to get PostCSS input source.\n   *\n   * @example\n   * error.input.file //=> 'a.css'\n   * error.file       //=> 'a.sass'\n   */;\n\n  return CssSyntaxError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar _default = CssSyntaxError;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["_picocolors","_interopRequireDefault","require","_terminalHighlight","CssSyntaxError","message","line","column","source","file","plugin","_this","_Error","call","name","reason","setMessage","Error","captureStackTrace","_assertThisInitialized","showSourceCode","color","_this2","css","default","isColorSupported","lines","split","start","Math","max","end","min","length","maxWidth","String","mark","text","red","bold","aside","gray","slice","map","index","number","gutter","spacing","replace","join","toString","code"],"sources":["C:\\Users\\dyd97\\OneDrive\\바탕 화면\\test-main\\node_modules\\postcss\\lib\\css-syntax-error.es6"],"sourcesContent":["import pico from 'picocolors'\n\nimport terminalHighlight from './terminal-highlight'\n\n/**\n * The CSS parser throws this error for broken CSS.\n *\n * Custom parsers can throw this error for broken custom syntax using\n * the {@link Node#error} method.\n *\n * PostCSS will use the input source map to detect the original error location.\n * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n * PostCSS will show the original position in the Sass file.\n *\n * If you need the position in the PostCSS input\n * (e.g., to debug the previous compiler), use `error.input.file`.\n *\n * @example\n * // Catching and checking syntax error\n * try {\n *   postcss.parse('a{')\n * } catch (error) {\n *   if (error.name === 'CssSyntaxError') {\n *     error //=> CssSyntaxError\n *   }\n * }\n *\n * @example\n * // Raising error from plugin\n * throw node.error('Unknown variable', { plugin: 'postcss-vars' })\n */\nclass CssSyntaxError extends Error {\n  /**\n   * @param {string} message  Error message.\n   * @param {number} [line]   Source line of the error.\n   * @param {number} [column] Source column of the error.\n   * @param {string} [source] Source code of the broken file.\n   * @param {string} [file]   Absolute path to the broken file.\n   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.\n   */\n  constructor (message, line, column, source, file, plugin) {\n    super(message)\n\n    /**\n     * Always equal to `'CssSyntaxError'`. You should always check error type\n     * by `error.name === 'CssSyntaxError'`\n     * instead of `error instanceof CssSyntaxError`,\n     * because npm could have several PostCSS versions.\n     *\n     * @type {string}\n     *\n     * @example\n     * if (error.name === 'CssSyntaxError') {\n     *   error //=> CssSyntaxError\n     * }\n     */\n    this.name = 'CssSyntaxError'\n    /**\n     * Error message.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'Unclosed block'\n     */\n    this.reason = message\n\n    if (file) {\n      /**\n       * Absolute path to the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.file       //=> 'a.sass'\n       * error.input.file //=> 'a.css'\n       */\n      this.file = file\n    }\n    if (source) {\n      /**\n       * Source code of the broken file.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.source       //=> 'a { b {} }'\n       * error.input.column //=> 'a b { }'\n       */\n      this.source = source\n    }\n    if (plugin) {\n      /**\n       * Plugin name, if error came from plugin.\n       *\n       * @type {string}\n       *\n       * @example\n       * error.plugin //=> 'postcss-vars'\n       */\n      this.plugin = plugin\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      /**\n       * Source line of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.line       //=> 2\n       * error.input.line //=> 4\n       */\n      this.line = line\n      /**\n       * Source column of the error.\n       *\n       * @type {number}\n       *\n       * @example\n       * error.column       //=> 1\n       * error.input.column //=> 4\n       */\n      this.column = column\n    }\n\n    this.setMessage()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError)\n    }\n  }\n\n  setMessage () {\n    /**\n     * Full error text in the GNU error format\n     * with plugin, file, line and column.\n     *\n     * @type {string}\n     *\n     * @example\n     * error.message //=> 'a.css:1:1: Unclosed block'\n     */\n    this.message = this.plugin ? this.plugin + ': ' : ''\n    this.message += this.file ? this.file : '<css input>'\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column\n    }\n    this.message += ': ' + this.reason\n  }\n\n  /**\n   * Returns a few lines of CSS source that caused the error.\n   *\n   * If the CSS has an input source map without `sourceContent`,\n   * this method will return an empty string.\n   *\n   * @param {boolean} [color] Whether arrow will be colored red by terminal\n   *                          color codes. By default, PostCSS will detect\n   *                          color support by `process.stdout.isTTY`\n   *                          and `process.env.NODE_DISABLE_COLORS`.\n   *\n   * @example\n   * error.showSourceCode() //=> \"  4 | }\n   *                        //      5 | a {\n   *                        //    > 6 |   bad\n   *                        //        |   ^\n   *                        //      7 | }\n   *                        //      8 | b {\"\n   *\n   * @return {string} Few lines of CSS source that caused the error.\n   */\n  showSourceCode (color) {\n    if (!this.source) return ''\n\n    let css = this.source\n    if (terminalHighlight) {\n      if (typeof color === 'undefined') color = pico.isColorSupported\n      if (color) css = terminalHighlight(css)\n    }\n\n    let lines = css.split(/\\r?\\n/)\n    let start = Math.max(this.line - 3, 0)\n    let end = Math.min(this.line + 2, lines.length)\n\n    let maxWidth = String(end).length\n\n    function mark (text) {\n      if (color && pico.red) {\n        return pico.red(pico.bold(text))\n      }\n      return text\n    }\n    function aside (text) {\n      if (color && pico.gray) {\n        return pico.gray(text)\n      }\n      return text\n    }\n\n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        let number = start + 1 + index\n        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '\n        if (number === this.line) {\n          let spacing =\n            aside(gutter.replace(/\\d/g, ' ')) +\n            line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ')\n          return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^')\n        }\n        return ' ' + aside(gutter) + line\n      })\n      .join('\\n')\n  }\n\n  /**\n   * Returns error position, message and source code of the broken part.\n   *\n   * @example\n   * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n   *                  //    > 1 | a {\n   *                  //        | ^\"\n   *\n   * @return {string} Error position, message and source code.\n   */\n  toString () {\n    let code = this.showSourceCode()\n    if (code) {\n      code = '\\n\\n' + code + '\\n'\n    }\n    return this.name + ': ' + this.message + code\n  }\n\n  /**\n   * @memberof CssSyntaxError#\n   * @member {Input} input Input object with PostCSS internal information\n   *                       about input file. If input has source map\n   *                       from previous tool, PostCSS will use origin\n   *                       (for example, Sass) source. You can use this\n   *                       object to get PostCSS input source.\n   *\n   * @example\n   * error.input.file //=> 'a.css'\n   * error.file       //=> 'a.sass'\n   */\n}\n\nexport default CssSyntaxError\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}